// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7 (swiftlang-5.7.0.127.4 clang-1400.0.29.50)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Au10tixPassiveFaceLivenessKit
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Au10tixCore
import Au10tixDetectorManager
@_exported import Au10tixPassiveFaceLivenessKit
import Au10tixSourceManager
import CoreGraphics
import CoreVideo
import Foundation
import Swift
import UIKit
import _Concurrency
import _StringProcessing
@objc(Au10xFaceError) public enum FaceError : Swift.Int {
  case faceTooClose = 100
  case faceTooCloseToBorder
  case faceCropped
  case faceNotFound
  case faceTooSmall
  case faceAngleTooLarge
  case tooManyFaces
  case faceIsOccluded
  case failedToReadImage
  case failedToWriteImage
  case failedToReadModel
  case failedToAllocate
  case invalidConfig
  case noSuchObject
  case failedToPreprocessImageWhilePredict
  case failedToPreprocessImageWhileDetect
  case failedToPredictLandmarks
  case invalidFuseMode
  case nullPtr
  case licenseError
  case invalidMeta
  case internalError
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct PFLResponse : Swift.Codable {
  public enum ErrorCode : Swift.String, Swift.Codable {
    case FACE_TOO_CLOSE
    case FACE_CLOSE_TO_BORDER
    case FACE_CROPPED
    case FACE_IS_OCCLUDED
    case FACE_NOT_FOUND
    case TOO_MANY_FACES
    case FACE_TOO_SMALL
    case FACE_ANGLE_TOO_LARGE
    case FAILED_TO_READ_IMAGE
    case FAILED_TO_WRITE_IMAGE
    case FAILED_TO_READ_MODEL
    case FAILED_TO_ALLOCATE
    case INVALID_CONFIG
    case NO_SUCH_OBJECT_IN_BUILD
    case FAILED_TO_PREPROCESS_IMAGE_WHILE_PREDICT
    case FAILED_TO_PREPROCESS_IMAGE_WHILE_DETECT
    case FAILED_TO_PREDICT_LANDMARKS
    case INVALID_FUSE_MODE
    case NULLPTR
    case LICENSE_ERROR
    case INVALID_META
    case UNKNOWN
    public var toFaceError: Au10tixPassiveFaceLivenessKit.FaceError {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let score: Swift.Double?
  public let quality: Swift.Double?
  public let probability: Swift.Double?
  public let statusCode: Swift.Int?
  public let message: Swift.String?
  public let error: Swift.String?
  public let error_code: Au10tixPassiveFaceLivenessKit.PFLResponse.ErrorCode?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct HDResponse : Swift.Codable {
  public let noneScore: Swift.String
  public let hatScore: Swift.String
  public let helmetScore: Swift.String
  public let isHelmet: Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension Au10tixPassiveFaceLivenessKit.HDResponse : Swift.Equatable {
  public static func == (a: Au10tixPassiveFaceLivenessKit.HDResponse, b: Au10tixPassiveFaceLivenessKit.HDResponse) -> Swift.Bool
}
extension Au10tixPassiveFaceLivenessKit.HDResponse : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public typealias QualityFaultOptions = Swift.Set<Au10tixPassiveFaceLivenessKit.QualityFault>
public enum QualityFault : Swift.Int {
  case unstable
  case deviceNotVerticle
  case faceNotDetectedInImage
  case helmetNotDetectedInImageAuto
  case helmetNotDetectedInImageManual
  case tooManyFaces
  case faceTooFarFromCamera
  case faceTooCloseToCamera
  case faceNotFacingDirectlyAtCamera
  case moveUp
  case moveDown
  case moveLeft
  case moveRight
  case holdSteady
  case noFault
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum PFLSessionError : Swift.Error {
  case missingCameraPermission
  case cameraRestricted
  case timedout
  case sessionTokenExpired
  case retriesEnded
  case livenessCheckNetworkTimeout
  case livenessCheckFailed(error: Swift.Error)
  case helmetCheckNetworkTimeout
  case helmetCheckFailed(error: Swift.Error)
  case networkError(_: Swift.Error)
  case recordingFailed(_: Au10tixCore.ScreenRecorderError)
  case offline
}
public protocol PFLSessionDelegate : AnyObject {
  func pflSession(_ pflSession: Au10tixPassiveFaceLivenessKit.PFLSession, didCapture image: Foundation.Data, qualityFeedback: Au10tixPassiveFaceLivenessKit.QualityFaultOptions, faceBoundingBox: CoreFoundation.CGRect?, isHelmet: Swift.Bool, asHat: Swift.Double, asHelmet: Swift.Double, asNone: Swift.Double)
  func pflSession(_ pflSession: Au10tixPassiveFaceLivenessKit.PFLSession, didRecieve qualityFeedback: Au10tixPassiveFaceLivenessKit.QualityFaultOptions)
  func pflSession(_ pflSession: Au10tixPassiveFaceLivenessKit.PFLSession, didConcludeWith result: Au10tixPassiveFaceLivenessKit.PFLResponse, for image: Foundation.Data)
  func pflSession(_ pflSession: Au10tixPassiveFaceLivenessKit.PFLSession, didPassProbabilityThresholdFor image: Foundation.Data)
  func pflSession(_ pflSession: Au10tixPassiveFaceLivenessKit.PFLSession, didFailWith error: Au10tixPassiveFaceLivenessKit.PFLSessionError)
  func pflSession(_ pflSession: Au10tixPassiveFaceLivenessKit.PFLSession, didStartValidating image: Foundation.Data)
}
public protocol PFLSessionRecordingDelegate : AnyObject {
  func pflSessionRecorder(_ screenRecorder: Au10tixCore.ScreenRecorder, didFailToRecord error: Au10tixCore.ScreenRecorderError)
  func pflSessionRecorderDidStart(_ screenRecorder: Au10tixCore.ScreenRecorder)
  func pflSessionRecorderDidStop(_ screenRecorder: Au10tixCore.ScreenRecorder)
}
public struct PFLLogManager {
  public static var shared: Au10tixPassiveFaceLivenessKit.PFLLogManager
  public enum Category : Swift.String {
    case error
    case introPage
    case scanner
    case imageReview
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension Au10tixCore.SDKLogEvent {
  convenience public init(category: Au10tixPassiveFaceLivenessKit.PFLLogManager.Category, action: Au10tixCore.Log.Action, isUi: Swift.Bool = false)
}
public enum ValidationFlow : Swift.Int {
  case identityVerification
  case faceComparision
  public func dataType() -> Swift.Int
  public var screenRecordingDataType: Swift.Int {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class PFLSession : Au10tixCore.Au10tixSession, Au10tixCore.CameraSession, Au10tixCore.ImageProvidableSession {
  public var videoOutputURL: Foundation.URL {
    get
  }
  public var isAvailable: Swift.Bool {
    get
  }
  public var isCameraActive: Swift.Bool {
    get
  }
  public var authenticator: Au10tixCore.Au10tixSessionAuthenticator
  weak public var delegate: Au10tixPassiveFaceLivenessKit.PFLSessionDelegate?
  weak public var recordingDelegate: Au10tixPassiveFaceLivenessKit.PFLSessionRecordingDelegate?
  public var isEmbeddedInAnotherSession: Swift.Bool
  public var detectionDelay: Foundation.TimeInterval?
  public var isMicrophoneEnabled: Swift.Bool
  public var detectHelmet: Swift.Bool
  public var faceDetectionInManualCapture: Swift.Bool
  public var uiLicenseKey: Swift.String {
    get
    set
  }
  public var validationFlow: Au10tixPassiveFaceLivenessKit.ValidationFlow {
    get
  }
  convenience public init()
  public func set(responseQueue: Dispatch.DispatchQueue)
  public func start(with token: Swift.String, previewView: UIKit.UIView, refresh: Swift.Bool = true, didStartHandler: @escaping (Swift.Result<Swift.String, Au10tixCore.Au10tixCorePrepareError>) -> Swift.Void)
  public func stop()
  public func captureImage(_ source: Au10tixCore.Au10ImageSource)
  public func pauseCamera()
  public func resumeCamera(_ refresh: Swift.Bool = true)
  public func provide(image: Foundation.Data, exif: [Swift.String : Any], orientation: ImageIO.CGImagePropertyOrientation)
  public func recapture()
  public func validateImage(_ image: Foundation.Data)
  public func validateHDImage(_ image: Foundation.Data, source: Au10tixCore.Au10ImageSource, token: Swift.String, completion: ((_ feedback: Au10tixPassiveFaceLivenessKit.QualityFault?, _ faceBoundingBox: CoreFoundation.CGRect?, _ hdResponse: Au10tixPassiveFaceLivenessKit.HDResponse?) -> ())?)
  public func validateLiveness(for probability: Swift.Double) -> Swift.Bool
  public func resultShouldBeDesignatedTo(flow: Au10tixPassiveFaceLivenessKit.ValidationFlow)
  @objc deinit
}
extension Au10tixPassiveFaceLivenessKit.PFLSession : Au10tixCore.TimeoutableSessionDelegate {
  public func sessionTimedout(_ timeoutable: Au10tixCore.Timeoutable)
}
@objc public enum PassiveFaceLivenessUpdateType : Swift.Int {
  case imageCaptured
  case qualityFeedback
  case passedThreshold
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension Au10tixPassiveFaceLivenessKit.FaceError : Swift.Equatable {}
extension Au10tixPassiveFaceLivenessKit.FaceError : Swift.Hashable {}
extension Au10tixPassiveFaceLivenessKit.FaceError : Swift.RawRepresentable {}
extension Au10tixPassiveFaceLivenessKit.PFLResponse.ErrorCode : Swift.Equatable {}
extension Au10tixPassiveFaceLivenessKit.PFLResponse.ErrorCode : Swift.Hashable {}
extension Au10tixPassiveFaceLivenessKit.PFLResponse.ErrorCode : Swift.RawRepresentable {}
extension Au10tixPassiveFaceLivenessKit.QualityFault : Swift.Equatable {}
extension Au10tixPassiveFaceLivenessKit.QualityFault : Swift.Hashable {}
extension Au10tixPassiveFaceLivenessKit.QualityFault : Swift.RawRepresentable {}
extension Au10tixPassiveFaceLivenessKit.PFLLogManager.Category : Swift.Equatable {}
extension Au10tixPassiveFaceLivenessKit.PFLLogManager.Category : Swift.Hashable {}
extension Au10tixPassiveFaceLivenessKit.PFLLogManager.Category : Swift.RawRepresentable {}
extension Au10tixPassiveFaceLivenessKit.ValidationFlow : Swift.Equatable {}
extension Au10tixPassiveFaceLivenessKit.ValidationFlow : Swift.Hashable {}
extension Au10tixPassiveFaceLivenessKit.ValidationFlow : Swift.RawRepresentable {}
extension Au10tixPassiveFaceLivenessKit.PassiveFaceLivenessUpdateType : Swift.Equatable {}
extension Au10tixPassiveFaceLivenessKit.PassiveFaceLivenessUpdateType : Swift.Hashable {}
extension Au10tixPassiveFaceLivenessKit.PassiveFaceLivenessUpdateType : Swift.RawRepresentable {}
